<head>
    <link rel="stylesheet" href="/src/tabs/ind.-study/styles.css">
</head>

<body>
    <h1>independent study 2021/22</h1>

    <!--Intro-->
    <h3 class="section-header">Overview and Goals:</h3>
    <ul>
        <li>
            Develop some real-world Computer Science skills outside the rather limited AP Computer Science subset or browser-based tools.
        </li>
        <li>
            Form the basis of a decently professional portfolio that displays some level of variety in platform, language, and purpose.
        </li>
    </ul>
    <p class="indent">
        Looking at the syllabus of sorts I had set for myself, <em>ambitious</em> is definitely a word that comes to mind. We'll come back to this. Overall, though, I think I ended up meeting my goals, even if the goalposts shifted quite a bit from when I first envisioned this year.
    </p>

    <h3 class="section-header">Methodology:</h3>
    <p class="indent">
        If there's one thing I've learned this year, it's that learning and growth don't happen linearly, or smoothly, or really in any way that's easy to put into a presentation, so this is going to be a bit of a mess. I'll be going in roughly chronological order, but honestly that might be more of an exception than a rule. Additionally, some of the bigger projects I've worked on will get sections alongside the rest of the concepts I covered in coursework.
    </p>

    <!--Git-->
    <h3 class="section-header">Section 1: Git (and Github) (and code management in general)</h3>
    <p class="indent">
        Learning to use Git was one of the big revolutions in the way I code, I had known of its existence and approximate purpose before, but actually using it was a huge boost to productivity and also opened a lot of opportunities for collaboration in code.
    </p>
        <!--git diagram-->
    <p class="indent">
        Git can be thought of as a Google Drive built specifically code, and it stores any given programming project in a repository full of all of the project files. The files are stored at various stages in development, with a stage being created every time a <em>commit</em> is made, which essentially saves the file at the time of commit. This, in combination with other features such as being able to roll back commits to undo changes or create new branches of the project to test new features, has made Git one of the most important tools in my workflow, and is honestly something that should be taught at the principles level of Computer Science.
    </p>

    <!--Basic HTML & CSS-->
    <h3 class="section-header">Section 2: HTML & CSS</h3>
    <p class="indent">
        HyperText Markup Language and Cascading Style Sheets are the two languages that form the basis of the web as we know it. While neither are technically programming languages, they are quite powerful, and the shortcomings of both can be compensated for with JavaScript.
    </p> 
    <h4>HTML</h4>
    <p class="indent">
        HyperText Markup Language is pretty simple in concept: You wrap text in certain tags that make the text behave the way you want it to. This could be a header < h1-6 >, or a paragraph < p >, as well as more functional things like links < a >, or buttons < button >. These tags and their text get nested inside of one another to create a tree-like structure that describes what the page contains and how it contains it, but without CSS this will just appear like old, broken websites that are just a list of hyperlinks on a page with some unformatted text. In order for the text to appear in a fashion that makes sense to us, CSS is necessary.
    </p>
    <h4>CSS</h4>
    <p class="indent">
        Cascading Style Sheets are how all of the elements of HTML get their style, like background color, font type, size, and where they're placed on the page. While most elements have default styles, they are typically not good looking, for example: <button>Button</button>. CSS works through a selector and a block of styles. The selector selects (duh) for different elements, and can be very broad or very narrow. Below is a section of CSS from this page, used to style the tab buttons.
    </p>
    <code>
<pre>#header .tab-selector button {
    margin: auto var(--tab-margin);
    padding: auto 5px;
    border: 0px;
    outline: 0;
    background: none;
    color: var(--text-color);
    transition: margin 0.5s, font-size 0.5s;
}</pre>
    </code>
    <p>
        The selector "#header .tab-selector button" defines all button elements that are children of elements with the tab-selector class, that are in turn children of the element with an id of "header." Basically, the selector can allow us to select throughout the hierarchy of HTML, whether it be with ids, unique names that can only be given to one element, classes, which describe groups of similarly-styled elements, or tag names, which are the types of elements like "button" or "div" (division). There's a lot more to it than this however, and creating a responsive website that can work on a phone or tablet as well as a computer can start to become a real challenge.
    </p>
    <p class="indent">
        Flexbox is the most common remedy for this. Basically, it is set up with the display set to flex, and then it is given parameters like what direction the boxes should flow in (row or column), whether the boxes wrap around to a new line, and if or how they grow or shrink to fit the page. This is one of the easiest ways to make a page more mobile-responsive immediately, but fine tuning will be required.
    </p>
    <p class="indent">
        The other tool commonly used is media queries. In short, with a few lines of CSS, we can determine if the window is below a certain size, and apply styles accordingly. This is the media query section of this page:
    </p>
    <code>
<pre>@media (max-width: 800px) {
    #container {
        width: 100%;
        transition: width 0.5s;
    }
    #header {
        padding: 0px;
        overflow: auto;
        border-radius: 0px
    }
    #header .title {
        font-size: x-large;
    }
    #header .tab-selector button {
        margin: var(--tab-margin) var(--tab-margin);
    }
    #header .tab-selector button.active {
        font-size: 105%;
    }
    #content {
        border-radius: 0px;
    }
}</pre>
    </code>
    <p>
        Armed with all of this knowledge inside my noggin, I decided to have a crack at a website myself, using the domain graciously hosted by Github so I don't have to pay for it.
    </p>

    <!--Website Pt 1-->
    <h3 class="section-header">Project: Website</h3>
    <p class="indent">
        Some things are better left forgotten, and the first few iterations of <a href="/src/tabs/ind.-study/src/website-old/index.html" target="_blank">this website</a> are proof of that. It certainly could be worse, but not by a substantial amount.
    </p>
    <iframe loading="lazy" src="/src/tabs/ind.-study/src/website-old/index.html"></iframe>
    <p class="indent">
        Admittedly, when scaled down this much and viewed from a distance, it doesn't look quite so bad. But worse than ugly, it was horrifically unorganized and the code behind it was sloppy. Now, usually code will turn into a mess, it's simply a function of complexity and size, but this was the kind of messy that didn't even manage to work. I used a table for the sidebar, instead of the buttons that are built to be used as such, and every click on the page threw at least one or two errors, despite most of the code being blanketed in try/catch blocks meant to handle errors.
    </p>
    <p class="indent">
        With this in mind, I decided to learn a little more about web design before creating greater affronts to the field. This turned out to be a big mistake.
    </p>

    <!--Django, SCSS-->
    <h3 class="section-header">Section 3: Django, Python, and the Folly of Man</h3>
    <p class="indent">
        One thing the Web Design course really liked to hammer in was that, actually, the tools that have been the basis of web design for decades are garbage. Instead, the best thing to do is to abstract away as much of this as possible behind esoteric libraries and compilers. 
    </p>
    <p class="indent">
        The first to be introduced was Sass, which is a way to compile CSS from a different syntax. Writing in Sass allows the user to use more features of programming languages, i.e. variables and nested selectors. This presents itself as very useful, and when I first learned of it, I was really excited to use it, however I quickly found that it was more trouble than it was worth. Compiling from a different language makes the CSS very difficult to debug, as you have to constantly go back and forth between the two files, one of which you didn't write so you don't really know where everything is and how it's written, and it ends up being a huge mess. This would be a small nag, but the majority of time spent on front-end web development is debugging CSS, so this gets to be a pain quite quickly. Besides, the introduction of what are basically variables in CSS's custom properties (where you see var(--property)) renders Sass a lot more of a hindrance than a help.
    </p>
    <p class="indent">
        Django is a similar story if I'm honest. It's a rather obtuse framework, and using it seems cool on the surface, but really doesn't feel like it applies at a small scale level like this. It's a Python library that works basically as a backend for a website. It manages your website and its paths through a bunch of manifest files that go a little something like this:
    </p>
    <code>
<pre>
    Here's all of the things I want you to load: 
    Here's a file path: 
    # Here's a commented prayer to the gods of computer science
</pre>
    </code>
    <p>
        Now I'm digging into it a lot, but the Django framework is impressive in its scalability, and does make creating really big sites like Wikipedia possible, but it's really impractical to use without the help of a team, and like Sass, it create a whole slew of entry points for bugs that are just a nightmare to deal with, because instead of debugging 5 or 10 files, there's 15 or 20, and any one of them could be the issue.
    </p>

    <!--Cities-js-->
    <h3 class="section-header">Project: Cities with the Canvas API</h3>
    <p class="indent">
        Around this time I had starting playing NEO Scavenger, a survival-horror game based around the experience of the average person unfortunate enough to live in Michigan. While playing, I noticed the background of the Detroit Mega-City was quite pretty, as well as making a good background without being too uninteresting.
    </p>
    <img src="/src/tabs/ind.-study/src/images/dmc.jpg" onclick="enlarge()">
    <p>
        Thinking about it, I thought something similar would be great as a background for a website. There was a hitch, in that I am a terrible artist, but I'm a bad programmer too, and I figured maybe the two would cancel each other out and I'd get something usable. As you may have noticed from the background, this did end up working out, which I'm quite pleased about.
    </p>
    <iframe loading="lazy" src="/src/tabs/ind.-study/src/city.html"></iframe>
    <p class="indent">
        This was achieved almost entirely through JavaScript, which I think demonstrates well how nicely integrated the three main web languages are, and why I'm hesitant to be gung-ho about Django or Sass. This would form the basis of the next iteration of <a href="/src/tabs/ind.-study/src/website-new/index.html" target="_blank">this website</a> and this time, surely, it would look good...
    </p>
    <iframe loading="lazy" src="/src/tabs/ind.-study/src/website-new/index.html"></iframe>
    <p>
        Well, there's always next time. Nevertheless, every skill not directly related to making things look good was improving, and I figured I'd come back to it later.
    </p>

    <!--SQL-->
    <h3 class="section-header">SQL</h3>
    <p class="indent">
        Structured Query Language, or SQL, is a language built specifically to interact with databases. Databases are usually just massive tables, with a set number of columns and variable number of rows. SQL is just the language though, and the database itself needs to be created and hosted to be interacted with. MySQL and PostgreSQL are pretty common, but are also pretty heavy-duty and run on hardware separate from the website, so we used SQLite throughout the course. 
    </p>
    <p class="indent">
        SQL databases can be created and interacted with through the shell, but the course usually defaults to Django's models feature that allows for a higher-level management of the databases, basically creating the database in code as a "model," then using a "migration" to turn it into an actual SQLite database. This is all good, but the main issue it presents is that you don't end up learning anything else, and you can only really use Django if you want to integrate SQL into a website, which I don't really like. You probably see why by now.
    </p>

    <!--Testing-->
    <h3 class="section-header">Testing</h3>
    <p class="indent">
        Testing was covered in both Web Design and the Python-focused courses. In every language, testing boils down to the same thing--using "assert" statements to make sure the output of a function matches what's expected. In Python, this looks something like:
    </p>
    <code>
<pre>
assert reverse_name("James Jenkins") == "Jenkins, James"
</pre>
    </code>
    <p>
        If these two do not equal each other, an AssertionError will be thrown, and it's easy to see what went wrong and where. Usually, though, the tests are for more complex things, and are run in their own test files. This has the potential to really speed up development, but unfortunately it's hard to work it in to the relatively small projects and have it be worthwhile. Still, a good thing to have in the toolbox.
    </p>
    
    <!--Scalability & Security-->
    <h3 class="section-header">Scalability and Security</h3>
    <p class="indent">
        Scalability in this course was in large part covered by Django, and I think I've expounded enough on that. Security, while not something that's particularly concerning at the small, personal website level, is certainly important. The main worry with Web Development is Cross-Site Scripting, or XSS. Essentially, it is a vulnerability that allows malicious code to be executed on other people's computers, and can be used to steal cookies, passwords, accounts, or other sensitive information. The risk is mediated, first and foremost, by not handling anything sensitive yourself, so I'm quite ahead of the game there, but also by using proper scripting policies like script tags. The most important thing is to not let users execute code on the site at any point.
    </p>

    <!--Custom-ntp-->
    <h3 class="section-header">Project: Custom New Tab Page</h3>
    <p class="indent">
        Let's talk about security then. I had been seeing custom Chrome new tab pages around for a while, and figured it would be a fun weekend project. What it ended up being was a lesson on Google's Content Security Policy and documentation which can be summed up as strict and insufficient, respectively.
    </p>
    <p class="indent">
        The idea and execution were pretty simple, just a small search bar and a box with an image and some links that I frequent. One small thing I wanted, however, was for the search bar to start small and grow as it was typed in, until reaching half of the width of the screen, at which point the text would roll over. This is fairly easy, it requires a couple lines of CSS and one line JavaScript. Getting the JavaScript to run, though, was an issue. Chrome really doesn't want to run scripts that are embedded in the HTML file in a script tag. This is good for security, but it makes it difficult to run scripts. From poking around at other extensions I saw that all that used scripts just linked them from an external file, so I thought this would fix it. It didn't. I spent more than a few days trying to figure out what was wrong with it, trying a lot of different boneheaded solutions, before realizing that I just need to wait for the DOM to load before attaching EventListeners to elements. This was rather embarrassing, and could've easily been avoided with good documentation on Chrome's side, but what matters is it's done, and I think it looks alright.
    </p>
    <img src="/src/tabs/ind.-study/src/images/ntp.png">
    <img src="/src/tabs/ind.-study/src/images/ntp2.png">

    <!--CI/CD-->
    <h3 class="section-header">Continuous Integration/Continuous Deployment</h3>
    <p class="indent">
        CI/CD is the concept of a development pipeline that helps streamline the process from development to testing to releasing by utilizing frequent, small commits to shared repositories (continuous integration), which is then usually checked by an automated system for errors in merging the code, preventing merge hell. It increases the speed at which builds can be written, and makes small errors easy to catch early instead of letting them snowball. This is really useful but once again, it's quite hard to deploy and at any small scale, even the projects I've collaborated on merging hasn't been an issue because development is expedited and done with 2 people at most.
    </p>

    <!--Start of Python Course & Advanced projects-->
    <h3 class="section-header">IT & Automation: Or How I Learned to Stop Worrying and Love the Python</h3>
    <p class="indent">
        Python was a language I still had next to no experience with outside of Django, and after that mess, I was pretty disheartened moving into this course. I've come around though, and I think now I would say Python is really great for the kinds of things I would have earlier used Node for. This course was made by Google however, and as such was quite differently structured. The learning, to me, felt better condensed and more readily applicable for use at more scales, and part of that is that it's a fair bit easier to do with a much less broad topic, but I digress. The graded material consisted of miniature projects that involved connecting to a Linux virtual machine, and using the terminal to navigate around it and code solutions and fixes into the base given to you, which was a whole lot of fun, and good terminal usage practice.
    </p>

    <!--term-todo-->
    <h3 class="section-header">Term-Todo: a terminal-based replacement for my todo chart</h3>
    <p class="indent">
        Recently, I switched from running MacOS on my school computer to Linux. I had always kept track of my work through a table in a sticky note, but this wasn't really an option anymore, as I was now using a tiling window manager that made most sticky apps a pain to deal with. The solution was a program able to print an ASCII table to my terminal using the contents of a .csv file that I could write to. This used most of what I had learned in the first few parts of this course: the sys, os, csv, and subprocess modules, as well as a healthy dose of regular Python.
    </p>
    <code>
<pre>
#!/usr/bin/env python3

import sys, os, csv, subprocess
from printables import Table
from shutil import get_terminal_size

path = os.path.dirname(__file__) + os.sep

def fetch_data(name):
    data = []
    with open("{}data{}.csv".format(path, os.sep + name)) as file:
        for line in csv.reader(file):
            row = []
            for string in line:
                row.append(string.strip())
            data.append(row)
        file.close()
    return data

def main(args):
    available_files = os.listdir(path + "data")
    available_files.sort()

    # Enable ANSI colors in win
    os.system("")

    if len(args) == 1:
        for file in available_files:
            name = file.replace(".csv", "")
            data = fetch_data(name)
            t = Table(data)
            t.addLabel(name)
            t.setWidth(get_terminal_size((80, 24))[0])
            print(t.toString())
    else:
        try:
            if args[1] == "list":
                for file in available_files:
                    print(file.replace(".csv", ""))
                return
            
            if len(args) == 3 and args[2] != "":
                csv_path = path + "data{}.csv".format(os.sep + args[2])

                if args[1] == "remove":
                    os.remove(csv_path)

                if args[1] == "write":
                    subprocess.call(["nano", csv_path])
                return
                    
            t = Table(fetch_data(args[1]))
            t.addLabel(args[1])
            t.setWidth(get_terminal_size((80, 24))[0])
            print(t.toString())

        except FileNotFoundError:
            print("No file found.")

main(sys.argv)
</pre>
    </code>
    <p>
        The core of this was the printables.py file I wrote, which set up a class that would turn a 2D Array into an ASCII table. This presented a lot of fun challenges, like the string concatenation to create the table itself, and the truncation of strings to new lines, which involved using recursion for the first time outside of an example in APCSA.
    </p>
    <img src="/src/tabs/ind.-study/src/images/todo.png">
    <img src="/src/tabs/ind.-study/src/images/todo-edit.png">

    <!--disk-yeast-->
    <h3 class="section-header">Project: Disk Yeast</h3>
    <p class="indent">
        Another consequence of my switch to Linux was that, since I kept half of my storage to maintain a Mac partition, I had significantly reduced available storage. This shouldn't be an issue, except I'm quite bad at managing my files, and usually my Desktop and Downloads folders end up full of junk that fills up my disk that I never delete. My solution to this was of course something entirely overengineered: Disk Yeast, named as such because the goal was to "leaven" the disk, and create extra space.
    </p>
    <code>
<pre>
#!/usr/bin/env -S python3 -u

import os, re, sys, time, shutil

file_timeout = 0
last_check = 0
drive_path = ""
managed_dirs = []

def main():
    update("\rStarting...")
    os.chdir(__file__.replace("swap_storage.py",""))

    try:
        with open(os.path.relpath("config"), "r", encoding="UTF-8") as config_file:
            configs = re.match(r"TIME=(\d+)\nDRIVE=(.+)\nPATH=(.+)", config_file.read())
            file_timeout = int(configs[1])
            drive_path = configs[2]
            managed_dirs = configs[3].split(":")
            config_file.close()
    except FileExistsError:
        print("Error loading config file settings.")
        return

    
    try:
        current_time = time.time()
        # While loop drive check 
        if not os.path.exists(drive_path):
            sys.stdout.write("\rSTBY: No drive")
        else:
            update("\rChecking...")

        for dir in managed_dirs:
            for file in os.listdir(dir):
                path = dir + os.sep + file
                access_time = os.stat(path).st_atime
                if (current_time - access_time >= file_timeout):
                    update("\rRDY: Move {} to {}".format(file, drive_path))
                    if not os.path.exists(drive_path + dir):
                        os.makedirs(drive_path + dir)
                    shutil.move(path, drive_path + dir)

        with open(os.path.relpath("runs.log"), "a", encoding="UTF-8") as log_file:
            log_file.write("\n{}".format(current_time))
            log_file.close()
        last_check = current_time
    except KeyboardInterrupt:
        print("\nStopped.")
        return
    except FileNotFoundError:
        if not os.path.exists(drive_path):
            update("\rSTBY: No drive")
        else:
            return
    except shutil.Error:
        shutil.rmtree(drive_path + path)
        shutil.move(path, drive_path + dir)
    except:
        print("\nERR: Exiting")
        return

def update(text):
    sys.stdout.write(text)
    sys.stdout.flush()

main()
</pre>
    </code>
    <p>
        Because this was so hacky, it's a good time to introduce the the bodging power of error handling. The try and except statements basically try to execute code, and if something goes wrong, it'll do it's very best to continue instead of breaking completely. This is mostly used with the KeyboardInterrupt argument, which detects if Ctrl+C or another break key is pressed, which stops the program, helpful for continuously running scripts like a system monitor.
    </p>

    <!--soundboard-->
    <h3 class="section-header">Project: Soundboard</h3>
    <p class="indent">
        The Soundboard was a project a friend and I had the idea of doing not too long ago, which is why it's not quite a finished product yet, but the basis does work. The two components were a React GUI and a Python Script, and I handled the script part. The idea was to be able to hold a button to record microphone input, and then press another to play it back over your mic. This has been done, but it's usually either a piece of hardware that costs around $300, or software that's $25, and we thought that was pretty exorbitant. This ended up being a lot of moving parts, and a cautionary tale to never handle audio programmatically.
    </p>
    <p class="indent">
        The thing that enables this is a Virtual Audio Cable or VAC, and it essentially just creates an output device like a speaker that instead of playing sound sends it to a corresponding input device used as a mic. What this program does, then, is take the real mic input, send it to the output device which is the VAC input device, and then record and play back the recording all within that stream. Also, the latency has to be reasonable, and the script has to be lightweight enough to run alongside everything else on your computer, and cross-platform. This is the current version:
    </p>
    <code>
<pre>
from time import time
import sounddevice as sd
import soundfile as sf
from pynput import keyboard
import numpy as np

# Vars
mic_in = 1
mic_out = 6
latency = 0.2 # min 0.2
last_callback = 0

rec_key = "+"
playback_key = "-"
recording = {"data": np.array([], np.float32), 
            "playback": np.array([], np.float32),
            "sr": 0,
            "vol": 1,
            "record_state": False}

#extra binds for uploaded sounds (TODO)
bindings = [{"key":playback_key, "data":recording["playback"], "sr":0, "vol": 1, "active":False}]

# Load configs

# Keyboard handler
def on_press(key):
    try:
        if key.char == rec_key:
            recording["record_state"] = True
        for sound in bindings:
            if key.char == sound["key"]:
                print(sound["key"] + " played")
                sound["active"] = True
                
    except KeyboardInterrupt:
        return False
    except AttributeError as ex:
        print(ex)

def on_release(key):
    try:
        if key.char == rec_key:
            recording["record_state"] = False 
            recording["playback"] = np.copy(recording["data"])
            recording["data"] = np.array([], np.float32)

            bindings[0]["data"] = recording["playback"]
            bindings[0]["sr"] = recording["sr"]
    except KeyboardInterrupt:
        return False
    except AttributeError as ex:
        print(ex)

def start_input():
    listener = keyboard.Listener(on_press=on_press, on_release=on_release)
    listener.start()

# Audio stream handler
def get_vol_multiplier(vol):
    return pow(2, (np.sqrt(np.sqrt(np.sqrt(vol))) * 192 - 192)/6)

def callback(indata, outdata, frames, time, status):
    if status:
        print(status)
    outdata[:] = indata

    
    if recording["record_state"]:
        global last_callback
        recording["data"] = np.append(recording["data"], np.frombuffer(indata, np.float32))
        recording["sr"] = (recording["sr"] + (frames / (time.currentTime - last_callback) * 2)) / 2
        #frames * 68.90625#(1584 * 60 + frames * 60) / 2
        last_callback = time.currentTime
    

    for sound in bindings:
        if sound["active"]:
            sound["active"] = False
            sd.default.device = mic_out
            # this should, by no means known to god, work, but it does
            print("sound sr {} | frames*60: {} ".format(sound["sr"], frames * 60))
            sd.play(sound["data"], sound["sr"])

def start_main_stream():
    print(sd.query_devices())
    try:
        with sd.Stream(device=(mic_in, mic_out), latency=latency, callback=callback):
            print("Press ctrl + c to exit")
            input() # keeps stream open (hacky)
    except KeyboardInterrupt:
        print("\nExited due to user input")
    except:
        print("\nExited due to error")

    sf.write("C:\\Users\\cyber\\Desktop\\Main\\soundboard_py\\record.wav", recording["playback"], 1584 * 60)

# main
def main():
    #load sounds into bindings as arrays
    #binds[0]["data"], binds[0]["fs"] = sf.read("C:\\Users\\cyber\\Desktop\\Main\\soundboard_py\\pda_objective.wav")
    start_input()
    start_main_stream()

main()
</pre>
    </code>

    <!--Website 3-->
    <h3 class="section-header">Project: The Latest but Certainly not Greatest</h3>
    <p class="indent">
        Now we return to this godforsaken website and finally clean it up, using everything we haven't been learning about recently at all, and this time, finally, the design is passable. Fetch is employed as opposed to the unwieldy XMLHttpRequest(), anonymous functions are limited, it runs more smoothly with more functionality. Most importantly, it's not god-awful to look at, at least I think, I don't trust myself after the last two tries.
    </p>
</body>